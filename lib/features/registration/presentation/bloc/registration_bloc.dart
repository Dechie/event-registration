import 'package:event_reg/features/registration/data/models/participant.dart';
import 'package:event_reg/features/registration/data/repositories/registration_repository.dart';
import 'package:event_reg/features/registration/presentation/bloc/registration_event.dart';
import 'package:event_reg/features/registration/presentation/bloc/registration_state.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class RegistrationBloc extends Bloc<RegistrationEvent, RegistrationState> {
  final RegistrationRepository repository;

  RegistrationBloc({required this.repository}) : super(RegistrationInitial()) {
    on<SendOTPEvent>(_onSendOTP);
    on<VerifyOTPEvent>(_onVerifyOTP);
    on<RegisterParticipantEvent>(_onRegisterParticipant);
    on<ResetRegistrationEvent>(_onResetRegistration);
  }

  Future<void> _onSendOTP(
    SendOTPEvent event,
    Emitter<RegistrationState> emit,
  ) async {
    emit(RegistrationLoading());
    
    try {
      await repository.sendOTP(event.email);
      emit(OTPSentState(email: event.email));
    } catch (e) {
      emit(RegistrationErrorState(message: e.toString()));
    }
  }

  Future<void> _onVerifyOTP(
    VerifyOTPEvent event,
    Emitter<RegistrationState> emit,
  ) async {
    emit(RegistrationLoading());
    
    try {
      final isValid = await repository.verifyOTP(event.email, event.otp);
      if (isValid) {
        emit(OTPVerifiedState());
      } else {
        emit(RegistrationErrorState(message: 'Invalid OTP. Please try again.'));
      }
    } catch (e) {
      emit(RegistrationErrorState(message: e.toString()));
    }
  }

  Future<void> _onRegisterParticipant(
    RegisterParticipantEvent event,
    Emitter<RegistrationState> emit,
  ) async {
    emit(RegistrationLoading());
    
    try {
      final participant = Participant(
        id: '', // Will be generated by backend
        fullName: event.fullName,
        gender: event.gender,
        dateOfBirth: event.dateOfBirth,
        nationality: event.nationality,
        phoneNumber: event.phoneNumber,
        email: event.email,
        region: event.region,
        city: event.city,
        woreda: event.woreda,
        idNumber: event.idNumber,
        occupation: event.occupation,
        organization: event.organization,
        department: event.department,
        industry: event.industry,
        yearsOfExperience: event.yearsOfExperience,
        photoUrl: event.photoPath,
        selectedSessions: event.selectedSessions,
        createdAt: DateTime.now(),
      );

      final result = await repository.registerParticipant(participant);
      
      emit(RegistrationSuccessState(
        participant: result.participant,
        qrCode: result.qrCode,
      ));
    } catch (e) {
      emit(RegistrationErrorState(message: e.toString()));
    }
  }

  Future<void> _onResetRegistration(
    ResetRegistrationEvent event,
    Emitter<RegistrationState> emit,
  ) async {
    emit(RegistrationInitial());
  }
}

